diff --git a/glsl/render.frag b/glsl/render.frag
index 8bf1d56..0f90965 100644
--- a/glsl/render.frag
+++ b/glsl/render.frag
@@ -9,7 +9,7 @@ uniform float uGridSize;
 
 varying float vCoord;
 
-vec2 textureCoord(float particleNumber) {
+vec2 getUVFromIndex(float particleNumber) {
     float interval = 1.0/uGridSize;
     vec2 uv;
     uv.x = interval * (mod(particleNumber, uGridSize) + 0.5);
@@ -18,5 +18,5 @@ vec2 textureCoord(float particleNumber) {
 }
 
 void main(void) {
-    gl_FragColor = texture2D(uParticleDensityData, textureCoord(vCoord))/1000.0;
+    gl_FragColor = texture2D(uParticleDensityData, getUVFromIndex(vCoord))/10000.0;
 }
diff --git a/glsl/render.vert b/glsl/render.vert
index c074f7f..a19ef09 100644
--- a/glsl/render.vert
+++ b/glsl/render.vert
@@ -61,14 +61,6 @@ void main(void) {
     vec2 uv = getUVFromIndex(aParticleIndex);
     vec4 particle = texture2D(uParticlePositionData, uv);
     vCoord = aParticleIndex;
-    vec3 pos = particle.rgb;
-    vec2 nIndex = (voxelIndex(pos) + 0.5)/u_ngrid_resolution;
-    vec4 ind = texture2D(uParticleNeighborData, nIndex);
-    if (ind.r == aParticleIndex || ind.g == aParticleIndex || ind.b == aParticleIndex || ind.a == aParticleIndex) {
-        gl_Position = uPMatrix * uMVMatrix * particle;
-    } else {
-        gl_Position = uPMatrix * uMVMatrix * (particle - vec4(0.5, 0.0, 0.0, 0.0));
-    }
-
+    gl_Position = uPMatrix * uMVMatrix * particle;
     gl_PointSize = 3.0;
 }
diff --git a/glsl/velocity.frag b/glsl/velocity.frag
index 7baa364..31a5e20 100644
--- a/glsl/velocity.frag
+++ b/glsl/velocity.frag
@@ -98,8 +98,8 @@ vec3 computeForce(float index) {
 
 
     vec3 vel = getVelocity(textureCoord(index)).rgb - getVelocity(gl_FragCoord.xy/uViewportSize).rgb;
-    force1 += vel*uMass*viscosityKernel(dist)/myDensity;
-    return force1/998.23;
+    //force1 += vel*uMass*viscosityKernel(dist)/myDensity;
+    return force1/150.0;
 }
 
 vec3 computeForceContribution(vec3 offset) {
@@ -164,21 +164,26 @@ void main(void) {
     force3 += computeForceContribution(vec3(-1.0, 1.0, -1.0));
     force3 += computeForceContribution(vec3(-1.0, -1.0, 1.0));
 
+    vel += 0.005*(force3);
 
-    vec3 center = vec3(0.5);
-    vec3 local = pos - center;
-    vec3 box = vec3(0.48);
-    vec3 contactLocal = min(box, max(-box, local));
-
-    float cDist = length(contactLocal + center - pos);
-    
-    if (cDist > 0.0 && length(vel) > 0.0) {
-        vec3 normal = normalize(sign(contactLocal - local));
-        float rest = cDist/(0.01 * length(vel));
-        vel -= (1.0 + rest) * dot(vel, normal) * normal;
+    if (pos.x > 1.0) {
+        vel.x = -abs(vel.x) * 0.2;
+    }
+    if (pos.y > 1.0) {
+        vel.y = -abs(vel.y) * 0.2;
+    }
+    if (pos.z > 1.0) {
+        vel.z = -abs(vel.z) * 0.2;
+    }
+    if (pos.x < 0.0) {
+        vel.x = abs(vel.x) * 0.2;
+    }
+    if (pos.y < 0.0) {
+        vel.y = 9.8*0.01;
+    }
+    if (pos.z < 0.0) {
+        vel.z = abs(vel.z) * 0.2;
     }
-
-    vel += 0.005*(force3);
 
     vel += 0.005*vec3(0.0, -9.8, 0.0);
 
diff --git a/js/entry.js b/js/entry.js
index 0fbbbd1..ebf5690 100644
--- a/js/entry.js
+++ b/js/entry.js
@@ -215,7 +215,7 @@ $(document).ready(function() {
         setupControls(simulator);
         setMouseHandlers(canvas, simulator);
 
-        render = function() {
+        var render = function() {
             gl.clearColor(0.0, 0.0, 0.0, 1.0);
             gl.enable(gl.DEPTH_TEST);
             console.log("rendering frame");
diff --git a/js/simulation.js b/js/simulation.js
index 382a63a..2e493a9 100644
--- a/js/simulation.js
+++ b/js/simulation.js
@@ -2,7 +2,7 @@ var Simulation = function(gl, programs) {
     this.gl = gl;
     this.programs = programs;
 
-    this.gridSize = 200;
+    this.gridSize = 256;
     this.viscosity = 0.01;
     this.debug = false;
     this.auto = true;
@@ -17,9 +17,9 @@ var Simulation = function(gl, programs) {
 
     // Assuming uniform grid where there is an equal number of elements
     // In each direction
-    this.spaceSide = 49; // The length of a dimension in world space
+    this.spaceSide = 36; // The length of a dimension in world space
     this.particleDiameter = 1; // The diameter of a particle / side length of voxel
-    this.searchRadius = 0.045;
+    this.searchRadius = 0.07;
     this.weightConstant = 315.0/(64*Math.PI*Math.pow(this.searchRadius, 9));
     this.wPressureConstant = 15.0/(Math.PI*Math.pow(this.searchRadius, 6));
 
@@ -42,11 +42,6 @@ var Simulation = function(gl, programs) {
     // Total side length of the 2D neighborhood grid
     this.neighborGridSide = this.metagridUnit * this.metagridSide;
 
-    var renderbuffer = this.neighborRenderbuffer = gl.createRenderbuffer();
-    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
-    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.neighborGridSide, this.neighborGridSide);
-    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
-
     var mvMatrix = this.mvMatrix = mat4.create();
     var pMatrix = this.pMatrix = mat4.create();
     mat4.identity(pMatrix);
@@ -503,9 +498,6 @@ Simulation.prototype.updateNeighbors = function() {
 
     // We'll be doing this computation in four passes
     gl.bindFramebuffer(gl.FRAMEBUFFER, this.neighborFramebuffer);
-    gl.bindRenderbuffer(gl.RENDERBUFFER, this.neighborRenderbuffer);
-    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.neighborRenderbuffer);
-
     gl.viewport(0, 0, s, s);
     gl.clearColor(0.0, 0.0, 0.0, 0.0);
     gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
@@ -551,7 +543,6 @@ Simulation.prototype.updateNeighbors = function() {
 
     // Clean up
     gl.bindFramebuffer(gl.FRAMEBUFFER, null);
-    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
     gl.colorMask(true, true, true, true);
     gl.disable(gl.STENCIL_TEST);
     gl.disable(gl.DEPTH_TEST);
